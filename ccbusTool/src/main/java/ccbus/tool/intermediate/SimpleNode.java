/* Generated By:JJTree: Do not edit this line. SimpleNode.java Version 6.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=true,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package ccbus.tool.intermediate;


import java.util.function.Supplier;

public
class SimpleNode implements Node {

  protected Node parent;
  protected Node[] children;
  protected int id;
  protected Object value;

  protected Token firstToken;
  protected Token lastToken;

  protected int cntNodeTraversedLastSearch=0;
  protected int subRootSearchId=0;
  protected int cntNode;

  SymTab symTab;

  public SimpleNode(int i) {
    id = i;
  }


  public void jjtOpen() {
  }

  public void jjtClose() {
  }

  public void jjtSetParent(Node n) { parent = n; }
  public Node jjtGetParent() { return parent; }

  public void jjtAddChild(Node n, int i) {
    if (children == null) {
      children = new Node[i + 1];
    } else if (i >= children.length) {
      Node c[] = new Node[i + 1];
      System.arraycopy(children, 0, c, 0, children.length);
      children = c;
    }
    children[i] = n;
  }

  public Node jjtGetChild(int i) {
    return children[i];
  }

    public Node jjtSetChild(int i,Node node) {
        return children[i]=node;
    }

  public int jjtGetNumChildren() {
    return (children == null) ? 0 : children.length;
  }

  public void jjtSetValue(Object value) { this.value = value; }
  public Object jjtGetValue() { return value; }

  public Token jjtGetFirstToken() { return firstToken; }
  public void jjtSetFirstToken(Token token) { this.firstToken = token; }
  public Token jjtGetLastToken() { return lastToken; }
  public void jjtSetLastToken(Token token) { this.lastToken = token; }

  /* You can override these two methods in subclasses of SimpleNode to
     customize the way the node appears when the tree is dumped.  If
     your output uses more than one line you should override
     toString(String), otherwise overriding toString() is probably all
     you need to do. */

  public String toString(String prefix) { return prefix + toString(); }

  /* Override this method if you want to customize how the node dumps
     out its children. */

  public void dump(String prefix) {
    System.out.println(toString(prefix));
    if (children != null) {
      for (int i = 0; i < children.length; ++i) {
        SimpleNode n = (SimpleNode)children[i];
        if (n != null) {
          n.dump(prefix + " ");
        }
      }
    }
  }

  public int getId() {
    return id;
  }
    public void setId(int id)
    {
        this.id=id;
    }

  public Node findFirstDownById(int id,int depth)
  {
      if(0==depth)
      {
          return null;
      }
      for (int i = 0;children!=null && i < children.length; ++i)
      {
          SimpleNode n = (SimpleNode)children[i];
          if (n.getId() == id)
          {
              return n;
          }
          SimpleNode nn=(SimpleNode)n.findFirstDownById(id,depth-1);
          if(null!=nn)
          {
              return nn;
          }
      }
      return null;
  }

  public void resetNextSearch()
  {
      cntNodeTraversedLastSearch=0;
  }

    public Node findNextDownById(int id,int depth)
    {
        if(id!=subRootSearchId)
        {
            subRootSearchId = id;
            cntNodeTraversedLastSearch=0;
        }
        cntNode=0;
        return findNextDownByIdImpl(id,depth,this);
    }

    public Node findFirstDownById(int id)
    {
        return findFirstDownById(id,-1);
    }

    protected Node findNextDownByIdImpl(int id,int depth,SimpleNode subRoot)
    {
        if(0==depth)
        {
            return null;
        }
        for (int i = 0;children!=null && i < children.length; ++i)
        {
            SimpleNode n = (SimpleNode)children[i];
            subRoot.cntNode++;
            if (n.getId() == id && subRoot.cntNode>subRoot.cntNodeTraversedLastSearch)
            {
                subRoot.cntNodeTraversedLastSearch=subRoot.cntNode;
                return n;
            }
            SimpleNode nn=(SimpleNode)n.findNextDownByIdImpl(id,depth-1,subRoot);
            if(null!=nn)
            {
                return nn;
            }
        }
        return null;
    }

    public Node findLeaf()
    {
        Node leaf;
        leaf=this;
        while(leaf.jjtGetNumChildren()>0)
        {
            leaf=leaf.jjtGetChild(0);
        }
        return leaf;
    }

    public Node findFirstUpById(int id)
    {
        Node up=this.jjtGetParent();
        while(null!=up && up.getId()!=id)
        {
            up=up.jjtGetParent();
        }
        if(null!=up && up.getId()==id)
        {
            return up;
        }
        return null;
    }

    public Node findFirstUpById(int id,int depth)
    {
        if(0==depth)
        {
            return null;
        }
        Node up=this.jjtGetParent();
        while(up.getId()!=id)
        {
            if(0==depth)
            {
                return null;
            }
            up=up.jjtGetParent();
            depth--;

        }
        if(up.getId()==id)
        {
            return up;
        }
        return null;
    }

    public void add(Node n)
    {
        jjtAddChild(n,jjtGetNumChildren());
        n.jjtSetParent(this);
    }

    public String image()
    {
        return jjtGetFirstToken().image;
    }

    public Node getNode(){return this;}

    public Node createCopy(int id)
    {
        SimpleNode result=new SimpleNode(id);
        result.jjtSetFirstToken(jjtGetFirstToken());
        result.jjtSetLastToken(jjtGetLastToken());
        return result;
    }

    public Node createCopy()
    {
        SimpleNode result=new SimpleNode(this.getId());
        result.jjtSetFirstToken(Token.newToken(jjtGetFirstToken().kind,jjtGetFirstToken().image));
        result.jjtSetLastToken(Token.newToken(jjtGetLastToken().kind,jjtGetLastToken().image));
        return result;
    }

    public <T> Node createCopyGeneric(Supplier<T> supplier)
    {
        Node result=(Node)supplier.get();
        result.setId(this.getId());
        result.jjtSetFirstToken(Token.newToken(jjtGetFirstToken().kind,jjtGetFirstToken().image));
        result.jjtSetLastToken(Token.newToken(jjtGetLastToken().kind,jjtGetLastToken().image));
        return result;
    }

    public SymTab symTab() {
        return symTab;
    }

    public void symTab(SymTab st) {
        symTab=st;
    }

    public void resetChildren()
    {
        children=null;
    }

    public void detach()
    {
        SimpleNode parentTemp= (SimpleNode)jjtGetParent();
        jjtSetParent(null);

        int remove=-1;
        for(int i=0;i<parentTemp.jjtGetNumChildren();i++)
        {
            if(parentTemp.jjtGetChild(i)==this)
            {
                remove=i;
            }
        }
        if(-1==remove)
        {
            // Should throw error
            System.out.println("Cannot detach child");
            return;
        }
        // allocate memory length - 1
        Node[] childrenTmp = new Node[parentTemp.children.length-1];

        // copy before index
        System.arraycopy(parentTemp.children,0,childrenTmp,0,remove);

        // copy after index, skip removed one
        System.arraycopy(
                parentTemp.children, remove+1,
                childrenTmp, remove,
                parentTemp.children.length-1-remove);

        // replace static array with new allocated
        parentTemp.children=childrenTmp;
    }
}

/* JavaCC - OriginalChecksum=08e1124af241001787f19514d354826c (do not edit this line) */
